---
title: "Project1"
author: '----'
date: "01 11 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Создание единой таблицы с данными
Данный чанк содержит функцию open_f. Для создания единой таблицы с данными, пожалуйста, передайте функции путь к папке, где находятся файлы.

```{r table}
dt<-data.frame()
files_opener <- function(p){
  library(data.table)
  all.files <- list.files(path=p,pattern = ".csv",full.names = T)
  l <- lapply(all.files, fread, sep=",")
  dt <<- rbindlist(l)
}
files_opener("C:/Users/Alexandra Dolgikh/Downloads/Data/")
dt<-as.data.frame(dt)
colnames(dt)[2]<-'Sex'
```
### После создания таблицы нам нужно проверить ее на:

* целостность
* корректность данных

Сначала проверим, что число наблюдений равно **4177**:

```{r nrow}
nrow(dt)
```

Видим, что таблица действительно содержит 4177 значений.

Далее необходимо проверить данные на **корректность**.

Поскольку в данной работе проводилось измерение количественных параметров, логично предположить, что все столбцы кроме переменной Sex должны быть типа *numeri*c. Для проверки этого воспользуемся функцией str


```{r str}
str(dt)
```
Видим, что первые три столбца представляют тип character. Для начала проверим, все ли значения этих столбцов записаны в числовом виде. Начнем со столбца **Sex**

```{r apply}
unique(sort(dt$Sex))
```

Видим, что помимо значений 1,2,3, которые исходя из названий столбца означают мужской, женский пол и ювенильную стадию, есть также отклоняющиеся значения. Заменим их общими вариантами(1,2,3), сразу переведем вектор в factor и проверим результат.

```{r}
dt$Sex <- gsub(dt$Sex, pattern = "male", replacement = 1)
dt$Sex <- gsub(dt$Sex, pattern = "one", replacement = 1)
dt$Sex <- gsub(dt$Sex, pattern = "three", replacement = 1)
unique(sort(dt$Sex))
```

Аналогичную операцию проведем со столбцом **Rings**

```{r}
unique(sort(dt$Rings))
```

Опять видим, что есть значение записанное не цифрами, изменим это и сразу проверим.

```{r}
dt$Rings <- gsub(dt$Rings, pattern = "nine", replacement = 9)
unique(sort(dt$Rings))
```

Теперь поработаем со столбцом **Length**. Если посмотреть начало таблицы видим, что в этом столбце находятся числовые значения, тем не менее тип вектора - character. Сначала, не изменяя столбец попробуем перевести этот вектор в numeric, присвоив это значение другой переменной. При превращении вектора в numeric значения, которые не могут быть переведены в числовой вид, будут преобразованы в NA, а значит, выбрав только те строчки исходной таблицы, где в векторе x содержатся *NA*, может посмотреть, какие же именно это значения.

Как мы видим, лишь в одном случае у нас в исходной таблица в столбце Length было не *NA*. Тем не менее этим значением является упоминание о том, что данные также отсутствуют, так что смело можем переводить эту ячейку в *NA*.

```{r,warning=FALSE}
x<-as.numeric(dt$Length)
dt[is.na(x),]

dt$Length <- as.numeric(dt$Length)
```
Проверим результат
```{r}
str(dt)
```

Что же делать с NA? Есть вариант убрать строчки,содержащие NA, но он уберет довольно много данных.
```{r}
dt_wo_na <- dt[complete.cases(dt),]
```

Второй вариант это заменить NA на среднее. Чтобы исключить замену NA на среднее в факторной переменной Sex сделаем соответсвующий фильтр:

```{r, message=FALSE}
library(dplyr)
```
```{r,warning=FALSE}
dt <- dt %>% mutate_if(is.numeric, funs(ifelse(is.na(.), mean(.,na.rm=T), .)))
```

Теперь можно приступить к рассчетам!

# Рассчеты

### Для начала нам нужно узнать, каково среднее значение длины раковины у различных полов, а также у ювенильной стадии, а затем и стандартное отклонение для тех же групп.
```{r}
m<-dt %>% filter(Sex!='NA') %>% group_by(Sex) %>% summarise(mean(Length))
s<-dt %>% filter(Sex!='NA') %>% group_by(Sex) %>% summarise(sd(Length))
print(m)
```
```{r}
print(s)
```

### Теперь узнаем у какого процента моллюсков значение переменной Height не превышает 0.165

```{r}
height165 <- dt%>% filter(Height <= 0.165)
Height_percent <- nrow(height165)/nrow(dt)*100
print(round(Height_percent,2))
```

### Теперь узнаем значение переменной Length выше чем у 92%

Для начала вычислим, сколько наблюдений составляют 92%

```{r}
0.92*4177
```

Теперь, найдем 3843 наблюдение в отсортированном векторе *Length*

```{r}
Length_sort <- sort(dt$Length)
Length_sort[3843]
```

Наконец проведем Z-стандартизацию переменной Length и сохраним получившийся вектор как Length_z_scores

```{r}
Length_z_scores <- (dt$Length - mean(dt$Length,na.rm=T))/sd(dt$Length)
```

# Сравнения и выявление корреляций

## сравнение диаметра моллюсков с 5 и 15 кольцами

Для сравнения диаметра раковины у улиток с 5 и 15 кольцами для начала нужно сохранить значения диаметра, относящиеся к этим двум группам в отдельные вектора

```{r}
library(ggplot2)
Diameter_5 <- dt %>% filter(Rings==5) %>% select(Diameter)
Diameter_15 <- dt %>% filter(Rings==15) %>% select(Diameter)
```

Теперь нужно определеиться с тем, параметрический или непараметрический тест будем использовать дял анализа. Для начала проверим сколько вообще значений включают данные группы.

```{r}
a<- length(Diameter_5$Diameter)
b<- length(Diameter_15$Diameter)
```

Получаем значения `r a` и `r b`, то есть объем не очень большой, поэтому перед применением параметрического теста проверим данные на нормальность.

```{r}
ggplot(Diameter_15,aes(x=Diameter_15[,1]))+geom_density(colour='green',fill='springgreen3',alpha=0.25)+xlab('Диаметр раковины')+ggtitle('Распределение значений диметра раковин у улиток с 15 кольцами')+theme_light()+geom_vline(aes(xintercept=mean(Diameter_15[,1])),linetype="dashed",colour='orange')
```

```{r}
ggplot(Diameter_5,aes(x=Diameter_5[,1]))+geom_density(colour='green',fill='springgreen3',alpha=0.25)+xlab('Диаметр раковины')+ggtitle('Распределение значений диметра раковин у улиток с 5 кольцами')+theme_light()+geom_vline(aes(xintercept=mean(Diameter_5[,1])),linetype="dashed",colour='orange')
```

```{r}
qqnorm(y=Diameter_15[,1],main="Q-Q Plot for group 15 Rings",xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Diameter_15[,1])
```

```{r}
qqnorm(Diameter_5[,1],main="Q-Q Plot for group 5 Rings",xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Diameter_5[,1])
```

Видим,что распределение значений близко к нормальному,поэтому для сравнения можем применить t-test.

```{r}
f <- t.test(Diameter_15,Diameter_5)
```

Видим, что t-значение больше табличного `r f$statistic` и значение p-value `r f$p.value`, значит отвергаем нулевую гипотезу о равенстве средних и принимаем альтернативную, а значит между значениями диаметра у улиток с 15 и 5 кольцами есть разница.

### Про корреляцию между Diameter и Whole_weight

Для того, чтобы проверить, есть ли зависимость между переменными, сделаем корреляционный анализ. Для начала проверим распределение на нормальность построив density_plot и Q-Q-Plot

```{r}
ggplot(dt,aes(x=Diameter))+geom_density(colour='blue',fill='steelblue1',alpha=0.25)+xlab('Диаметр')+ggtitle('Распределение значений диаметра')+theme_light()+geom_vline(aes(xintercept=mean(Diameter)),linetype="dashed",colour='steelblue1')

ggplot(dt,aes(x=Whole_weight))+geom_density(colour='blue',fill='steelblue1',alpha=0.25)+xlab('Вес моллюска')+ggtitle('Распределение значений веса моллюсков')+theme_light()+geom_vline(aes(xintercept=mean(Whole_weight)),linetype="dashed",colour='steelblue1')

qqnorm(dt$Diameter,main="Q-Q Plot for Diameter",xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(dt$Diameter)

qqnorm(dt$Whole_weight,main="Q-Q Plot for Whole weight",xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(dt$Whole_weight)
```

Видим, что распределение достаточно сильно отличается от нормального поэтому для рассчета коэффициента корреляции воспользуемся методом **Спирмена**

```{r,warning=FALSE}
sp <- cor.test(dt$Diameter, dt$Whole_weight, method ="spearman")
```

Видим, что коэффициент корреляции достаточно высок `r sp$estimate` и p.value `r sp$p.value`, исходя из чего заключаем, что связь между переменными есть, она положительная и довольно сильная.

# Собственные гипотезы

Логично предположить, что корреляция в размерах не ограничивается корреляцией между Whole_weight и Diameter.

Проверим наличие и других зависимостей. Для начала между различными показателями веса. Как минимум переменная Whole_weight распределена не нормально, так что воспользуемся методом Спирмена.

```{r,warning=FALSE}
sw <- cor.test(dt$Shucked_weight, dt$Whole_weight, method ="spearman")
vw <- cor.test(dt$Viscera_weight, dt$Whole_weight, method ="spearman")
shw <- cor.test(dt$Shell_weight, dt$Whole_weight, method ="spearman")

```

Получаем коэффициенты корреляции `r sw$estimate` , `r vw$estimate` `r shw$estimate`. То-есть корреляция между различными показателями веса действительно есть.

То же самое можно показать и для пары Height - Diameter
```{r,warning=FALSE}
hd <- cor.test(dt$Height, dt$Diameter, method ="spearman")
```
`r hd$estimate`

Проверим связь между количеством колец и, например, Length
````{r,warning=FALSE}
dt$Rings<-as.numeric(dt$Rings)
rl <- cor.test(dt$Rings, dt$Length, method ="spearman")
```
Получаем `r rl$estimate` что очевидно меньше, чем обнаруженные для других параметров коэффициенты корреляции.
Проверим еще Diameter

```{r,warning=FALSE}
rd <- cor.test(dt$Rings, dt$Diameter, method ="spearman")
```

`r rd$estimate`, тоже не очень высокое значение.

Визуализируем, как в целом соотносятся значения параметра Length и количество колец

Построим boxplot с группировкой по группам с разными количествами колец для значений вектора длины

```{r}
dt$Rings <- as.factor(dt$Rings)
ggplot(dt,aes(y=Length,x=Rings,group=Rings))+geom_boxplot()+ggtitle('График зависимости длины раковины от количества колец')
```

Видно, что до отметки 11 колец при увеличении количества колец длина также увеличивается, однако с увеличением количества колец больше 11 этого не происходит. Попробуем посчитать корреляцию для отфильтрованных данных.

```{r}
dt$Rings <- as.numeric(dt$Rings)
dt_less_11 <- dt[dt$Rings<11,]
a <- cor.test(dt_less_11$Rings,dt_less_11$Diameter)
b <- cor.test(dt_less_11$Rings,dt_less_11$Length)

```

Получаем для пары Rings-Length значение `r b$estimate`, а для Rings-Diameter `r a$estimate`
Видим, что в данных для которых значение Rings меньше 11 коэффициент корреляции  получился даже немного выше, чем в цельных данных.

А проверим для значений с больше чем 11 кольцами.

```{r}
dt_more_11 <- dt[dt$Rings>=11,]
c <- cor.test(dt_more_11$Rings,dt_more_11$Diameter)
d <- cor.test(dt_more_11$Rings,dt_more_11$Length)
```
Для Rings-Length `r d$estimate`, а для Rings-Diameter `r c$estimate`

Видим, что для моллюсков, у которых больше 11 колец, коэффициенты корреляции сильно меньше.

Проверим и некоторые другие парметры, например Whole_weight и Height

```{r}
e1 <- cor.test(dt_more_11$Rings,dt_more_11$Whole_weight)
f1 <- cor.test(dt_less_11$Rings,dt_less_11$Whole_weight)
e2 <- cor.test(dt_more_11$Rings,dt_more_11$Height)
f2 <- cor.test(dt_less_11$Rings,dt_less_11$Height)
```

Для Whole_weight видим для группы с количеством колец меньше 11 коэффициент корреляции `r f1$estimate` , а для группы больше 11 `r e1$estimate`, то есть практически 0. Для Height меньше 11 `r f2$estimate` , а больше 11 `r e2$estimate`.

Тенденция сохраняется

Таким образом, корреляция между количеством колец на раковине и такими параметрами как длина/диаметр/вес может значительно выше для особей с кольцами меньше 11, чем с больше чем 11. 

Если построим boxplot для визуализации того, как распределено количество колец для групп разного пола, видим, что у группы uvenil у большей части как раз количество колец на раковине меньше 11, соответственно там и коэффициент корреляция между кольцами и длиной/диаметром/весом должен быть выше, чем у male и female. Однако для рассчета коэффициента корреляции между Rings и Length разгруппированного по полам у нас недостаточно данных.

```{r}
dt_wo_na$Rings <- as.numeric(dt_wo_na$Rings)
ggplot(dt_wo_na,aes(y=Rings,color=dt_wo_na$Sex))+geom_boxplot()+ggtitle('График зависимости количества колец от пола')
```

